{"mappings":"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","sources":["<anon>","src/index.js","src/ZeroWidthApi.js","src/ZeroWidthApiExpress.js"],"sourcesContent":["var $e2pLI$express = require(\"express\");\nvar $e2pLI$compression = require(\"compression\");\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n$parcel$export(module.exports, \"ZeroWidthApi\", () => $497d2e909cf7dfb6$export$2e2bcd8739ae039);\n$parcel$export(module.exports, \"ZeroWidthApiExpress\", () => $1be5594902a7503e$export$2e2bcd8739ae039);\n// index.js\n/**\n * ZeroWidthApi is the main class for interacting with the ZeroWidth API.\n */ class $497d2e909cf7dfb6$var$ZeroWidthApi {\n    /**\n   * Constructor for initializing the ZeroWidthApi class.\n   * @param {Object} config - The configuration object.\n   * @param {string} config.secretKey - The secret key for authentication.\n   * @param {string} config.endpointId - The endpoint ID (deprecated).\n   * @param {string} config.projectId - The project ID (replacement for endpoint ID).\n   * @param {string} config.agentId - The agent ID.\n   * @param {string} [config.baseUrl] - The base URL for the API.\n   * @throws {Error} If required parameters are missing.\n   */ constructor({ secretKey: secretKey, endpointId: endpointId, projectId: projectId, agentId: agentId, baseUrl: baseUrl }){\n        if (!secretKey) throw new Error(\"Missing required constructor parameters: secretKey, projectId, and agentId should be provided\");\n        this.secretKey = secretKey.trim();\n        this.projectId = projectId || endpointId;\n        this.agentId = agentId;\n        this.baseUrl = baseUrl || \"https://api.zerowidth.ai/beta\";\n    }\n    /**\n   * Executes a tool function, handling both synchronous and asynchronous functions.\n   * @param {Function} toolFunction - The tool function to execute.\n   * @param {Object} args - The arguments to pass to the tool function.\n   * @returns {Promise<*>} The result of the tool function.\n   * @throws {Error} If the tool function throws an error.\n   */ async executeToolFunction(toolFunction, args) {\n        try {\n            const result = toolFunction(args);\n            if (result instanceof Promise) return await result;\n            else return result;\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Makes an API call to the specified endpoint.\n   * @param {string} endpoint - The API endpoint to call.\n   * @param {Object} [options={}] - Options for the API call.\n   * @param {string} [options.method='POST'] - The HTTP method to use.\n   * @param {Object} [options.headers] - Additional headers to include in the request.\n   * @param {Object} [options.body] - The body of the request.\n   * @returns {Promise<Object>} The response data from the API call.\n   * @throws {Error} If the API call fails.\n   */ async makeApiCall(endpoint, options = {}, originalRequest) {\n        const url = `${this.baseUrl}/${endpoint}`;\n        const headers = {\n            \"Authorization\": `Bearer ${this.secretKey}`,\n            \"Content-Type\": \"application/json\",\n            ...options.headers\n        };\n        const response = await fetch(url, {\n            method: options.method || \"POST\",\n            headers: headers,\n            body: options.body ? JSON.stringify(options.body) : undefined\n        });\n        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n        if (options.body && options.body.stream) return this.handleStreamedResponse({\n            readableStream: response.body,\n            originalRequest: originalRequest\n        });\n        else {\n            const responseData = await response.text(); // Ensure we read the text response\n            return JSON.parse(responseData); // Parse the JSON manually\n        }\n    }\n    /**\n   * Creates a new FetchEventSource instance for handling streaming responses.\n   * @param {ReadableStream} stream - The stream to process.\n   * @returns {FetchEventSource} The created FetchEventSource instance.\n   */ async createFetchEventSource(args) {\n        const eventSource = new this.FetchEventSource(args, this);\n        return eventSource;\n    }\n    /**\n   * Processes data using the specified endpoint and agent IDs.\n   * @param {Object} params - The parameters for processing.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} params.data - The data to process.\n   * @param {string} [params.userId] - The user ID for stateful processing.\n   * @param {string} [params.sessionId] - The session ID for stateful processing.\n   * @param {boolean} [params.stateful] - Whether the processing is stateful.\n   * @param {boolean} [params.verbose] - Whether to enable verbose output.\n   * @param {Object} [params.tools] - The tools to use for processing.\n   * @param {boolean} [params.stream] - Whether to enable streaming responses.\n   * @returns {Promise<Object>} The result of the processing.\n   * @throws {Error} If required parameters are missing or if the processing fails.\n   */ async process({ endpointId: endpointId, projectId: projectId, agentId: agentId, data: data, userId: userId, sessionId: sessionId, stateful: stateful, verbose: verbose, tools: tools, stream: stream, on: on } = {}) {\n        let pIdTouse = projectId || endpointId || this.projectId;\n        let url = `process/${pIdTouse}/${agentId || this.agentId}`;\n        if (verbose) url += \"?verbose=true\";\n        if (stateful && (!userId || !sessionId)) throw new Error(\"Stateful processing requires a userId and sessionId\");\n        const result = await this.makeApiCall(url, {\n            method: \"POST\",\n            body: {\n                user_id: userId,\n                session_id: sessionId,\n                stateful: stateful,\n                data: data,\n                stream: stream\n            }\n        }, {\n            stream: stream,\n            data: data,\n            projectId: pIdTouse,\n            agentId: agentId,\n            userId: userId,\n            sessionId: sessionId,\n            stateful: stateful,\n            verbose: verbose,\n            tools: tools,\n            on: on\n        });\n        if (stream) return;\n        else {\n            if (tools && result.output_data && result.output_data.tool_calls) {\n                let messageAutoAdded = false;\n                let autoProcessedTools = 0;\n                for (let tool_call of result.output_data.tool_calls){\n                    if (tool_call.type === \"function\") {\n                        if (tools.functions && tool_call.function && tools.functions[tool_call.function.name]) {\n                            if (!messageAutoAdded) {\n                                data.messages.push(result.output_data);\n                                messageAutoAdded = true;\n                            }\n                            const tool_result = await this.executeToolFunction(tools.functions[tool_call.function.name], JSON.parse(tool_call.function.arguments));\n                            data.messages.push({\n                                role: \"tool\",\n                                tool_call_id: tool_call.id,\n                                content: tool_result,\n                                timestamp: new Date().toISOString()\n                            });\n                            autoProcessedTools++;\n                        }\n                    }\n                }\n                if (autoProcessedTools === result.output_data.tool_calls.length) return await this.process({\n                    projectId: pIdTouse,\n                    agentId: agentId,\n                    data: data,\n                    userId: userId,\n                    sessionId: sessionId,\n                    stateful: stateful,\n                    verbose: verbose,\n                    tools: tools,\n                    stream: stream,\n                    on: on\n                });\n            }\n            return result;\n        }\n    }\n    /**\n   * Initializes the event source by reading from the stream and emitting events.\n   */ handleStreamedResponse = ({ readableStream: readableStream, originalRequest: originalRequest })=>{\n        let buffer = \"\";\n        let eventType = null;\n        let eventData = [];\n        let decoder = new TextDecoder(\"utf-8\", {\n            ignoreBOM: true,\n            fatal: true\n        });\n        let cumulative_progress = \"\";\n        let emit = (eventType, dataPacket)=>{\n            if (originalRequest.on && originalRequest.on[eventType]) originalRequest.on[eventType](dataPacket);\n            if (originalRequest.on && originalRequest.on[\"all\"]) originalRequest.on[\"all\"](eventType, dataPacket);\n        };\n        const processEvent = async ()=>{\n            if (eventType && eventData.length) {\n                const dataString = eventData.join(\"\\n\").trim();\n                try {\n                    const dataPacket = JSON.parse(dataString);\n                    if (eventType === \"outputProgress\") {\n                        if (dataPacket.partial_content === null || dataPacket.partial_content === undefined) dataPacket.partial_content = \"\";\n                        cumulative_progress += dataPacket.partial_content;\n                        dataPacket.content_so_far = cumulative_progress;\n                    }\n                    if (eventType === \"complete\") {\n                        let autoProcessedTools = 0;\n                        if (originalRequest.tools && dataPacket.output_data && dataPacket.output_data.tool_calls) {\n                            if (dataPacket.output_data.tool_calls.length > 0) {\n                                let messageAutoAdded = false;\n                                for (let tool_call of dataPacket.output_data.tool_calls)if (tool_call.type === \"function\") {\n                                    if (originalRequest.tools.functions && tool_call.function && originalRequest.tools.functions[tool_call.function.name]) {\n                                        if (!messageAutoAdded) {\n                                            originalRequest.data.messages.push(dataPacket.output_data);\n                                            messageAutoAdded = true;\n                                        }\n                                        emit(\"tool\", {\n                                            role: \"tool\",\n                                            tool_call: tool_call\n                                        });\n                                        const tool_result = await this.executeToolFunction(originalRequest.tools.functions[tool_call.function.name], JSON.parse(tool_call.function.arguments));\n                                        originalRequest.data.messages.push({\n                                            role: \"tool\",\n                                            tool_call_id: tool_call.id,\n                                            content: tool_result,\n                                            timestamp: new Date().toISOString()\n                                        });\n                                        autoProcessedTools++;\n                                    } else emit(\"tool\", {\n                                        role: \"tool\",\n                                        tool_call: tool_call\n                                    });\n                                }\n                                if (autoProcessedTools === dataPacket.output_data.tool_calls.length) return await this.process({\n                                    projectId: originalRequest.projectId,\n                                    agentId: originalRequest.agentId,\n                                    data: originalRequest.data,\n                                    userId: originalRequest.userId,\n                                    sessionId: originalRequest.sessionId,\n                                    stateful: originalRequest.stateful,\n                                    verbose: originalRequest.verbose,\n                                    tools: originalRequest.tools,\n                                    stream: originalRequest.stream,\n                                    on: originalRequest.on\n                                });\n                            }\n                        }\n                    }\n                    emit(eventType, dataPacket);\n                } catch (error) {\n                    emit(\"error\", error);\n                }\n            }\n            eventType = null;\n            eventData = [];\n        };\n        const readStream = async ()=>{\n            const reader = readableStream.getReader();\n            try {\n                while(true){\n                    const { done: done, value: value } = await reader.read();\n                    if (done) {\n                        if (buffer.trim() !== \"\") {\n                            buffer += \"\\n\\n\";\n                            if (eventType) await processEvent();\n                            else try {\n                                const dataPacket = JSON.parse(buffer.trim());\n                                emit(\"errorEvent\", dataPacket);\n                            } catch (error) {\n                                emit(\"error\", {\n                                    message: \"Failed to parse JSON\",\n                                    buffer: buffer\n                                });\n                            }\n                        }\n                        emit(\"close\");\n                        break;\n                    }\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split(\"\\n\");\n                    buffer = lines.pop(); // Retain incomplete line\n                    lines.forEach(async (line)=>{\n                        if (line.startsWith(\"event: \")) {\n                            if (eventType !== null) await processEvent();\n                            eventType = line.substring(7).trim();\n                        } else if (line.startsWith(\"data: \")) eventData.push(line.substring(6));\n                        else if (line.trim() === \"\") await processEvent();\n                    });\n                }\n            } catch (error) {\n                emit(\"error\", {\n                    message: \"Stream read error\",\n                    error: error\n                });\n            }\n        };\n        readStream();\n    };\n    /**\n   * Retrieves the history for a specific session.\n   * @param {Object} params - The parameters for retrieving the history.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {string} params.userId - The user ID.\n   * @param {string} params.sessionId - The session ID.\n   * @param {string} [params.startAfter] - The starting point for history retrieval.\n   * @returns {Promise<Object>} The history data.\n   * @throws {Error} If the API call fails.\n   */ async getHistory({ endpointId: endpointId, projectId: projectId, agentId: agentId, userId: userId, sessionId: sessionId, startAfter: startAfter } = {}) {\n        const endpoint = `history/${projectId || endpointId || this.projectId}/${agentId || this.agentId}/${userId}/${sessionId}`;\n        const params = startAfter ? {\n            startAfter: startAfter\n        } : {};\n        return this.makeApiCall(endpoint, {\n            method: \"GET\",\n            params: params\n        });\n    }\n    /**\n   * Submits a report for a specific session.\n   * @param {Object} params - The parameters for submitting the report.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} [params.data] - The optional JSON object containing the detailed API response.\n   * @param {string} [params.userId] - The user ID.\n   * @param {string} [params.sessionId] - The session ID.\n   * @param {string} params.type - The type of the report (e.g., 'positive', 'negative', 'neutral').\n   * @param {string} params.category - The category of the report (e.g., 'accuracy', 'hallucination').\n   * @param {string} [params.details] - Additional details provided by the user (max 500 characters).\n   * @returns {Promise<Object>} The result of the report submission.\n   * @throws {Error} If the API call fails.\n   */ async report({ endpointId: endpointId, projectId: projectId, agentId: agentId, data: data, userId: userId, sessionId: sessionId, type: type, category: category, details: details } = {}) {\n        // Construct the endpoint URL using provided or default IDs\n        const url = `report/${projectId || endpointId || this.projectId}/${agentId || this.agentId}`;\n        // Prepare the body of the POST request\n        const requestBody = {\n            user_id: userId || null,\n            session_id: sessionId || null,\n            data: data || null,\n            type: type,\n            category: category || null,\n            details: details || null // Optional: Additional user-provided details (string)\n        };\n        // Make the API call to submit the report\n        try {\n            const result = await this.makeApiCall(url, {\n                method: \"POST\",\n                body: requestBody\n            });\n            return result;\n        } catch (error) {\n            console.error(\"Error submitting report:\", error);\n            throw new Error(\"Failed to submit report\");\n        }\n    }\n    /**\n   * Formats an error object for better readability.\n   * @param {Error} error - The error object to format.\n   * @returns {Object} An object containing the formatted error message and status code.\n   */ formatError(error) {\n        let errorMessage = \"An error occurred\";\n        let statusCode = null;\n        if (error.response) {\n            errorMessage = `API Error: ${error.response.statusText || error.message}`;\n            statusCode = error.response.status;\n        } else if (error.request) errorMessage = \"Network Error: No response received from the server.\";\n        else errorMessage = `Request Error: ${error.message}`;\n        return {\n            errorMessage: errorMessage,\n            statusCode: statusCode\n        };\n    }\n}\nvar $497d2e909cf7dfb6$export$2e2bcd8739ae039 = $497d2e909cf7dfb6$var$ZeroWidthApi;\n\n\n// ZeroWidthApiMiddleware.js\n\n\n\nconst $1be5594902a7503e$var$processRouteHandler = async ({ req: req, res: res, next: next, secretKey: secretKey, baseUrl: baseUrl, returnsResponse: returnsResponse, variables: variables, tools: tools, on: on, useCompression: useCompression })=>{\n    const { project_id: project_id, agent_id: agent_id } = req.params;\n    const zerowidthApi = new (0, $497d2e909cf7dfb6$export$2e2bcd8739ae039)({\n        secretKey: secretKey,\n        projectId: project_id,\n        agentId: agent_id,\n        baseUrl: baseUrl\n    });\n    const processApiResponse = async (requestData)=>{\n        let eventsSentCounter = 0;\n        let closeTimeout;\n        if (variables) {\n            if (typeof variables === \"function\") {\n                let serverVariables = await variables(req);\n                requestData.data.variables = {\n                    ...requestData.data.variables,\n                    ...serverVariables\n                };\n            } else if (typeof variables === \"object\") requestData.data.variables = {\n                ...requestData.data.variables,\n                ...variables\n            };\n        }\n        try {\n            const result = await zerowidthApi.process({\n                ...requestData,\n                tools: tools,\n                on: {\n                    ...on,\n                    all: (eventType, data)=>{\n                        // Was the original requestData in stream mode?\n                        if (requestData.stream) {\n                            clearTimeout(closeTimeout);\n                            if (eventsSentCounter === 0) // open the SSE\n                            res.writeHead(200, {\n                                \"Content-Type\": \"text/event-stream\",\n                                \"Cache-Control\": \"no-cache\",\n                                \"Connection\": \"keep-alive\",\n                                \"X-Accel-Buffering\": \"no\"\n                            });\n                            eventsSentCounter++;\n                            // if the event is complete, close the connection after 1 second\n                            if (eventType === \"close\") {\n                                closeTimeout = setTimeout(()=>{\n                                    res.end();\n                                }, 5000);\n                                return;\n                            }\n                            // if the event is open, clear the timeout in case this is a reconnection\n                            if (eventType === \"open\") {\n                                clearTimeout(closeTimeout);\n                                if (eventsSentCounter > 1) return;\n                            }\n                            res.write(`event: ${eventType}\\n`);\n                            res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n                            if (useCompression) res.flush();\n                        }\n                    }\n                }\n            });\n            if (on && on.complete && result) on.complete(result);\n            return result;\n        } catch (error) {\n            console.error(\"API call failed:\", error);\n            if (on && on.error && error.response) on.error(error.response.data);\n            throw error;\n        }\n    };\n    try {\n        const finalResult = await processApiResponse(req.body);\n        if (req.body.stream) ;\n        else if (returnsResponse) res.json(finalResult.output_data);\n        else {\n            req.zerowidthResult = finalResult;\n            next();\n        }\n    } catch (error) {\n        next(error);\n    }\n};\nconst $1be5594902a7503e$var$historyRouteHandler = async ({ req: req, res: res, next: next, secretKey: secretKey, baseUrl: baseUrl, on: on, returnsResponse: returnsResponse })=>{\n    const { project_id: project_id, agent_id: agent_id, user_id: user_id, session_id: session_id } = req.params;\n    const { startAfter: startAfter } = req.query;\n    const zerowidthApi = new (0, $497d2e909cf7dfb6$export$2e2bcd8739ae039)({\n        secretKey: secretKey,\n        projectId: project_id,\n        agentId: agent_id,\n        baseUrl: baseUrl\n    });\n    try {\n        const history = await zerowidthApi.getHistory({\n            userId: user_id,\n            sessionId: session_id,\n            startAfter: startAfter\n        });\n        if (onProcess) onProcess(history);\n        if (returnsResponse) res.json(history);\n        else {\n            req.zerowidthHistory = history;\n            next();\n        }\n    } catch (error) {\n        console.error(\"History retrieval failed:\", error);\n        if (onError && error.response) onError(error.response.data);\n        res.status(500).send(\"Internal Server Error\");\n    }\n};\nfunction $1be5594902a7503e$export$2e2bcd8739ae039({ secretKey: secretKey, baseUrl: baseUrl, on: on, variables: variables, returnsResponse: returnsResponse = true, tools: tools, useCompression: useCompression = true }) {\n    const router = (0, ($parcel$interopDefault($e2pLI$express))).Router();\n    if (useCompression) router.use((0, ($parcel$interopDefault($e2pLI$compression)))());\n    // POST route to process data\n    router.post(\"/process/:project_id/:agent_id\", (req, res, next)=>{\n        $1be5594902a7503e$var$processRouteHandler({\n            req: req,\n            res: res,\n            next: next,\n            secretKey: secretKey,\n            baseUrl: baseUrl,\n            on: on,\n            variables: variables,\n            returnsResponse: returnsResponse,\n            tools: tools,\n            useCompression: useCompression\n        });\n    });\n    // GET route to retrieve history\n    router.get(\"/history/:project_id/:agent_id/:user_id/:session_id\", (req, res, next)=>{\n        $1be5594902a7503e$var$historyRouteHandler({\n            req: req,\n            res: res,\n            next: next,\n            secretKey: secretKey,\n            baseUrl: baseUrl,\n            on: on,\n            returnsResponse: returnsResponse\n        });\n    });\n    return router;\n}\n\n\n\n\n//# sourceMappingURL=main.cjs.map\n","// index.js\nimport ZeroWidthApi from './ZeroWidthApi.js';\nimport ZeroWidthApiExpress from './ZeroWidthApiExpress.js';\n\nexport { ZeroWidthApi, ZeroWidthApiExpress };\n","/**\n * ZeroWidthApi is the main class for interacting with the ZeroWidth API.\n */\nclass ZeroWidthApi {\n  /**\n   * Constructor for initializing the ZeroWidthApi class.\n   * @param {Object} config - The configuration object.\n   * @param {string} config.secretKey - The secret key for authentication.\n   * @param {string} config.endpointId - The endpoint ID (deprecated).\n   * @param {string} config.projectId - The project ID (replacement for endpoint ID).\n   * @param {string} config.agentId - The agent ID.\n   * @param {string} [config.baseUrl] - The base URL for the API.\n   * @throws {Error} If required parameters are missing.\n   */\n  constructor({ secretKey, endpointId, projectId, agentId, baseUrl }) {\n    if (!secretKey) {\n      throw new Error('Missing required constructor parameters: secretKey, projectId, and agentId should be provided');\n    }\n\n    this.secretKey = secretKey.trim();\n    this.projectId = projectId || endpointId;\n    this.agentId = agentId;\n    this.baseUrl = baseUrl || 'https://api.zerowidth.ai/beta';\n  }\n  \n\n  /**\n   * Executes a tool function, handling both synchronous and asynchronous functions.\n   * @param {Function} toolFunction - The tool function to execute.\n   * @param {Object} args - The arguments to pass to the tool function.\n   * @returns {Promise<*>} The result of the tool function.\n   * @throws {Error} If the tool function throws an error.\n   */\n  async executeToolFunction(toolFunction, args) {\n    try {\n      const result = toolFunction(args);\n      if (result instanceof Promise) {\n        return await result;\n      } else {\n        return result;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Makes an API call to the specified endpoint.\n   * @param {string} endpoint - The API endpoint to call.\n   * @param {Object} [options={}] - Options for the API call.\n   * @param {string} [options.method='POST'] - The HTTP method to use.\n   * @param {Object} [options.headers] - Additional headers to include in the request.\n   * @param {Object} [options.body] - The body of the request.\n   * @returns {Promise<Object>} The response data from the API call.\n   * @throws {Error} If the API call fails.\n   */\n  async makeApiCall(endpoint, options = {}, originalRequest) {\n    const url = `${this.baseUrl}/${endpoint}`;\n    const headers = {\n      'Authorization': `Bearer ${this.secretKey}`,\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n\n    const response = await fetch(url, {\n      method: options.method || 'POST',\n      headers,\n      body: options.body ? JSON.stringify(options.body) : undefined,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    if (options.body && options.body.stream) {\n      return this.handleStreamedResponse({\n        readableStream: response.body,\n        originalRequest: originalRequest\n      });\n    } else {\n      const responseData = await response.text(); // Ensure we read the text response\n      return JSON.parse(responseData); // Parse the JSON manually\n    }\n  }\n\n  /**\n   * Creates a new FetchEventSource instance for handling streaming responses.\n   * @param {ReadableStream} stream - The stream to process.\n   * @returns {FetchEventSource} The created FetchEventSource instance.\n   */\n  async createFetchEventSource(args) {\n    const eventSource = new this.FetchEventSource(args, this);\n    return eventSource;\n  }\n\n  /**\n   * Processes data using the specified endpoint and agent IDs.\n   * @param {Object} params - The parameters for processing.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} params.data - The data to process.\n   * @param {string} [params.userId] - The user ID for stateful processing.\n   * @param {string} [params.sessionId] - The session ID for stateful processing.\n   * @param {boolean} [params.stateful] - Whether the processing is stateful.\n   * @param {boolean} [params.verbose] - Whether to enable verbose output.\n   * @param {Object} [params.tools] - The tools to use for processing.\n   * @param {boolean} [params.stream] - Whether to enable streaming responses.\n   * @returns {Promise<Object>} The result of the processing.\n   * @throws {Error} If required parameters are missing or if the processing fails.\n   */\n  async process({ endpointId, projectId, agentId, data, userId, sessionId, stateful, verbose, tools, stream, on } = {}) {\n\n    let pIdTouse = projectId || endpointId || this.projectId;\n    \n    let url = `process/${pIdTouse}/${agentId || this.agentId}`;\n    if (verbose) url += \"?verbose=true\";\n\n    if (stateful && (!userId || !sessionId)) {\n      throw new Error(\"Stateful processing requires a userId and sessionId\");\n    }\n\n    const result = await this.makeApiCall(url, {\n      method: 'POST',\n      body: {\n        user_id: userId,\n        session_id: sessionId,\n        stateful,\n        data,\n        stream\n      }\n    }, {\n      stream,\n      data,\n      projectId: pIdTouse,\n      agentId,\n      userId,\n      sessionId,\n      stateful,\n      verbose,\n      tools,\n      on\n    });\n\n    if (stream) {\n      return;\n    } else {\n      if (tools && result.output_data && result.output_data.tool_calls) {\n        let messageAutoAdded = false;\n        let autoProcessedTools = 0;\n        for (let tool_call of result.output_data.tool_calls) {\n          if (tool_call.type === 'function') {\n            if (tools.functions && tool_call.function && tools.functions[tool_call.function.name]) {\n              if (!messageAutoAdded) {\n                data.messages.push(result.output_data);\n                messageAutoAdded = true;\n              }\n\n              const tool_result = await this.executeToolFunction(tools.functions[tool_call.function.name], JSON.parse(tool_call.function.arguments));\n              data.messages.push({\n                role: 'tool',\n                tool_call_id: tool_call.id,\n                content: tool_result,\n                timestamp: new Date().toISOString()\n              });\n              autoProcessedTools++;\n            }\n          }\n        }\n\n        if(autoProcessedTools === result.output_data.tool_calls.length){\n          return await this.process({\n            projectId: pIdTouse,\n            agentId,\n            data,\n            userId,\n            sessionId,\n            stateful,\n            verbose,\n            tools,\n            stream,\n            on\n          });\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Initializes the event source by reading from the stream and emitting events.\n   */\n  handleStreamedResponse = ({readableStream, originalRequest}) => {\n    let buffer = '';\n    let eventType = null;\n    let eventData = [];\n    let decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n    let cumulative_progress = \"\";\n\n    let emit = (eventType, dataPacket) => {\n      if(originalRequest.on && originalRequest.on[eventType]){\n        originalRequest.on[eventType](dataPacket);\n      }\n      if(originalRequest.on && originalRequest.on['all']){\n        originalRequest.on['all'](eventType, dataPacket);\n      }\n    }\n\n    const processEvent = async () => {\n      if (eventType && eventData.length) {\n        const dataString = eventData.join('\\n').trim();\n        try {\n          const dataPacket = JSON.parse(dataString);\n\n          if(eventType === 'outputProgress'){\n            if(dataPacket.partial_content === null || dataPacket.partial_content === undefined) dataPacket.partial_content = '';\n            cumulative_progress += dataPacket.partial_content;\n\n            dataPacket.content_so_far = cumulative_progress;\n          }\n\n          if(eventType === 'complete'){\n            \n            let autoProcessedTools = 0;\n            if (originalRequest.tools && dataPacket.output_data && dataPacket.output_data.tool_calls) {\n              \n              if(dataPacket.output_data.tool_calls.length > 0){\n                \n                let messageAutoAdded = false;\n                for (let tool_call of dataPacket.output_data.tool_calls) {\n\n                  if (tool_call.type === 'function') {\n\n                    if (originalRequest.tools.functions && tool_call.function && originalRequest.tools.functions[tool_call.function.name]) {\n                      \n                      if (!messageAutoAdded) {\n                        originalRequest.data.messages.push(dataPacket.output_data);\n                        messageAutoAdded = true;\n                      }\n\n                      emit('tool', {\n                        role: 'tool',\n                        tool_call: tool_call,\n                      });\n\n\n                      const tool_result = await this.executeToolFunction(originalRequest.tools.functions[tool_call.function.name], JSON.parse(tool_call.function.arguments));\n                      \n                      originalRequest.data.messages.push({\n                        role: 'tool',\n                        tool_call_id: tool_call.id,\n                        content: tool_result,\n                        timestamp: new Date().toISOString()\n                      });\n\n                      autoProcessedTools++;\n                    } else {\n                      emit('tool', {\n                        role: 'tool',\n                        tool_call: tool_call,\n                      });\n                    \n                    }\n                  }\n                }\n\n                if(autoProcessedTools === dataPacket.output_data.tool_calls.length){\n\n                  return await this.process({\n                    projectId: originalRequest.projectId,\n                    agentId: originalRequest.agentId,\n                    data: originalRequest.data,\n                    userId: originalRequest.userId,\n                    sessionId: originalRequest.sessionId,\n                    stateful: originalRequest.stateful,\n                    verbose: originalRequest.verbose,\n                    tools: originalRequest.tools,\n                    stream: originalRequest.stream,\n                    on: originalRequest.on\n                  });\n                }\n              }\n            }\n          }\n\n          emit(eventType, dataPacket);\n        } catch (error) {\n          emit('error', error);\n        }\n      }\n      eventType = null;\n      eventData = [];\n    };\n\n    const readStream = async () => {\n      const reader = readableStream.getReader();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            if (buffer.trim() !== '') {\n              buffer += '\\n\\n';\n              if (eventType) {\n                await processEvent();\n              } else {\n                try {\n                  const dataPacket = JSON.parse(buffer.trim());\n                  emit('errorEvent', dataPacket);\n                } catch (error) {\n                  emit('error', { message: 'Failed to parse JSON', buffer });\n                }\n              }\n            }\n            emit('close');\n            break;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop(); // Retain incomplete line\n\n          lines.forEach(async (line) =>{\n            if (line.startsWith('event: ')) {\n              if (eventType !== null) {\n                await processEvent();\n              }\n              eventType = line.substring(7).trim();\n            } else if (line.startsWith('data: ')) {\n              eventData.push(line.substring(6));\n            } else if (line.trim() === '') {\n              await processEvent();\n            }\n          });\n        }\n      } catch (error) {\n        emit('error', { message: 'Stream read error', error });\n      }\n    };\n\n    readStream();\n  }\n\n  /**\n   * Retrieves the history for a specific session.\n   * @param {Object} params - The parameters for retrieving the history.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {string} params.userId - The user ID.\n   * @param {string} params.sessionId - The session ID.\n   * @param {string} [params.startAfter] - The starting point for history retrieval.\n   * @returns {Promise<Object>} The history data.\n   * @throws {Error} If the API call fails.\n   */\n  async getHistory({ endpointId, projectId, agentId, userId, sessionId, startAfter } = {}) {\n    const endpoint = `history/${projectId || endpointId || this.projectId}/${agentId || this.agentId}/${userId}/${sessionId}`;\n    const params = startAfter ? { startAfter } : {};\n\n    return this.makeApiCall(endpoint, {\n      method: 'GET',\n      params: params,\n    });\n  }\n\n  /**\n   * Submits a report for a specific session.\n   * @param {Object} params - The parameters for submitting the report.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} [params.data] - The optional JSON object containing the detailed API response.\n   * @param {string} [params.userId] - The user ID.\n   * @param {string} [params.sessionId] - The session ID.\n   * @param {string} params.type - The type of the report (e.g., 'positive', 'negative', 'neutral').\n   * @param {string} params.category - The category of the report (e.g., 'accuracy', 'hallucination').\n   * @param {string} [params.details] - Additional details provided by the user (max 500 characters).\n   * @returns {Promise<Object>} The result of the report submission.\n   * @throws {Error} If the API call fails.\n   */\n  async report({ endpointId, projectId, agentId, data, userId, sessionId, type, category, details } = {}) {\n    // Construct the endpoint URL using provided or default IDs\n    const url = `report/${projectId || endpointId || this.projectId}/${agentId || this.agentId}`;\n\n    // Prepare the body of the POST request\n    const requestBody = {\n      user_id: userId || null,        // Optional: User ID\n      session_id: sessionId || null,  // Optional: Session ID\n      data: data || null,             // Optional: Detailed API response data (JSON object)\n      type,                           // Required: Type of the report (string)\n      category: category || null,     // Required: Category of the report (string)\n      details: details || null        // Optional: Additional user-provided details (string)\n    };\n\n    // Make the API call to submit the report\n    try {\n      const result = await this.makeApiCall(url, {\n        method: 'POST',\n        body: requestBody,\n      });\n      \n      return result;\n    } catch (error) {\n      console.error('Error submitting report:', error);\n      throw new Error('Failed to submit report');\n    }\n  }\n\n\n\n  /**\n   * Formats an error object for better readability.\n   * @param {Error} error - The error object to format.\n   * @returns {Object} An object containing the formatted error message and status code.\n   */\n  formatError(error) {\n    let errorMessage = \"An error occurred\";\n    let statusCode = null;\n\n    if (error.response) {\n      errorMessage = `API Error: ${error.response.statusText || error.message}`;\n      statusCode = error.response.status;\n    } else if (error.request) {\n      errorMessage = \"Network Error: No response received from the server.\";\n    } else {\n      errorMessage = `Request Error: ${error.message}`;\n    }\n\n    return { errorMessage, statusCode };\n  }\n}\n\nexport default ZeroWidthApi;","// ZeroWidthApiMiddleware.js\nimport express from 'express';\nimport ZeroWidthApi from './ZeroWidthApi.js'; \nimport compression from 'compression';\n\nconst processRouteHandler = async ({ req, res, next, secretKey, baseUrl, returnsResponse, variables,  tools, on, useCompression }) => {\n  const { project_id, agent_id } = req.params;\n\n  const zerowidthApi = new ZeroWidthApi({\n    secretKey: secretKey,\n    projectId: project_id,\n    agentId: agent_id,\n    baseUrl: baseUrl\n  });\n\n\n  const processApiResponse = async (requestData) => {\n\n    let eventsSentCounter = 0;\n    let closeTimeout;\n\n    if(variables){\n      if(typeof variables === 'function'){\n        let serverVariables = await variables(req);\n        requestData.data.variables = {\n          ...requestData.data.variables,\n          ...serverVariables\n        }\n      } else if(typeof variables === 'object'){\n        requestData.data.variables = {\n          ...requestData.data.variables,\n          ...variables\n        }\n      }\n    }\n\n    try {\n      const result = await zerowidthApi.process({\n        ...requestData,\n        tools: tools,\n        on: {\n          ...on,\n          all: (eventType, data) => {\n\n            // Was the original requestData in stream mode?\n            if (requestData.stream) {\n              clearTimeout(closeTimeout);\n\n              if(eventsSentCounter === 0) {\n                // open the SSE\n                res.writeHead(200, {\n                  'Content-Type': 'text/event-stream',\n                  'Cache-Control': 'no-cache',\n                  'Connection': 'keep-alive',\n                  'X-Accel-Buffering': 'no'\n                });\n              }\n\n              eventsSentCounter++;\n\n              // if the event is complete, close the connection after 1 second\n              if(eventType === 'close') {\n                closeTimeout = setTimeout(() => {\n                  res.end();\n                }, 5000);\n                return;\n              }\n\n              // if the event is open, clear the timeout in case this is a reconnection\n              if(eventType === 'open') {\n                clearTimeout(closeTimeout);\n                if(eventsSentCounter > 1) {\n                  return;\n                } \n              }\n\n              \n              res.write(`event: ${eventType}\\n`);\n              res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\n              if(useCompression) res.flush();\n            }\n          }\n        }\n      });\n\n      if(on && on.complete && result) {\n        on.complete(result);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('API call failed:', error);\n\n      if(on && on.error && error.response) {\n        on.error(error.response.data);\n      }\n\n      throw error;\n    }\n  };\n\n  try {\n    const finalResult = await processApiResponse(req.body);\n\n    if(req.body.stream){\n      // do nothing, on handlers will handle the response\n    } else {\n      if (returnsResponse) {\n        res.json(finalResult.output_data);\n      } else {\n        req.zerowidthResult = finalResult;\n        next();\n      }\n    }\n  } catch (error) {\n    next(error);\n  }\n};\n\n\nconst historyRouteHandler = async ({req, res, next, secretKey, baseUrl, on, returnsResponse}) => {\n  const { project_id, agent_id, user_id, session_id } = req.params;\n  const { startAfter } = req.query;\n  \n  \n  const zerowidthApi = new ZeroWidthApi({\n    secretKey: secretKey,\n    projectId: project_id,\n    agentId: agent_id,\n    baseUrl: baseUrl\n  });\n\n  try {\n    const history = await zerowidthApi.getHistory({\n      userId: user_id,\n      sessionId: session_id,\n      startAfter: startAfter,\n    });\n\n    if (onProcess) {\n      onProcess(history);\n    } \n    \n    if (returnsResponse) {\n      res.json(history);\n    } else {\n      req.zerowidthHistory = history;\n      next();\n    }\n  } catch (error) {\n    console.error('History retrieval failed:', error);\n\n    if(onError && error.response) {\n      onError(error.response.data);\n    }\n\n    res.status(500).send('Internal Server Error');\n  }\n};\n\nexport default function ZeroWidthApiExpress({ secretKey, baseUrl, on, variables, returnsResponse = true, tools, useCompression = true}) {\n  const router = express.Router();\n\n  if(useCompression){\n    router.use(compression());\n  }\n\n  // POST route to process data\n  router.post('/process/:project_id/:agent_id', (req, res, next) => {\n    processRouteHandler({req, res, next, secretKey, baseUrl, on, variables, returnsResponse, tools, useCompression});\n  });\n\n  // GET route to retrieve history\n  router.get('/history/:project_id/:agent_id/:user_id/:session_id', (req, res, next) => {\n    historyRouteHandler({req, res, next, secretKey, baseUrl, on, returnsResponse});\n  });\n\n  return router;\n}\n"],"names":["$e2pLI$express","require","$e2pLI$compression","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","module","exports","$497d2e909cf7dfb6$export$2e2bcd8739ae039","$1be5594902a7503e$export$2e2bcd8739ae039","constructor","secretKey","endpointId","projectId","agentId","baseUrl","Error","trim","executeToolFunction","toolFunction","args","result","Promise","error","makeApiCall","endpoint","options","originalRequest","url","headers","response","fetch","method","body","JSON","stringify","undefined","ok","status","stream","handleStreamedResponse","readableStream","responseData","text","parse","createFetchEventSource","eventSource","FetchEventSource","process","data","userId","sessionId","stateful","verbose","tools","on","pIdTouse","user_id","session_id","output_data","tool_calls","messageAutoAdded","autoProcessedTools","tool_call","type","functions","function","name","messages","push","tool_result","arguments","role","tool_call_id","id","content","timestamp","Date","toISOString","length","buffer","eventType","eventData","decoder","TextDecoder","ignoreBOM","fatal","cumulative_progress","emit","dataPacket","processEvent","dataString","join","partial_content","content_so_far","readStream","reader","getReader","done","value","read","message","decode","lines","split","pop","forEach","line","startsWith","substring","getHistory","startAfter","params","report","category","details","console","formatError","errorMessage","statusCode","statusText","request","$1be5594902a7503e$var$processRouteHandler","req","res","next","returnsResponse","variables","useCompression","project_id","agent_id","zerowidthApi","processApiResponse","requestData","closeTimeout","eventsSentCounter","serverVariables","all","clearTimeout","writeHead","setTimeout","end","write","flush","complete","finalResult","json","zerowidthResult","$1be5594902a7503e$var$historyRouteHandler","query","history","onProcess","zerowidthHistory","onError","send","router","Router","use","post"],"version":3,"file":"main.cjs.map"}