{"mappings":"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","sources":["src/index.js","src/ZeroWidthApi.js","src/ZeroWidthApiExpress.js"],"sourcesContent":["// index.js\nimport ZeroWidthApi from './ZeroWidthApi.js';\nimport ZeroWidthApiExpress from './ZeroWidthApiExpress.js';\n\nexport { ZeroWidthApi, ZeroWidthApiExpress };\n","import { time } from \"console\";\n\n/**\n * ZeroWidthApi is the main class for interacting with the ZeroWidth API.\n */\nclass ZeroWidthApi {\n  /**\n   * Constructor for initializing the ZeroWidthApi class.\n   * @param {Object} config - The configuration object.\n   * @param {string} config.secretKey - The secret key for authentication.\n   * @param {string} config.endpointId - The endpoint ID (deprecated).\n   * @param {string} config.projectId - The project ID (replacement for endpoint ID).\n   * @param {string} config.agentId - The agent ID.\n   * @param {string} [config.baseUrl] - The base URL for the API.\n   * @throws {Error} If required parameters are missing.\n   */\n  constructor({ secretKey, endpointId, projectId, agentId, baseUrl }) {\n    if (!secretKey) {\n      throw new Error('Missing required constructor parameters: secretKey, projectId, and agentId should be provided');\n    }\n\n    this.secretKey = secretKey.trim();\n    this.projectId = projectId || endpointId;\n    this.agentId = agentId;\n    this.baseUrl = baseUrl || 'https://api.zerowidth.ai/v1';\n  }\n  \n\n  /**\n   * Executes a tool function, handling both synchronous and asynchronous functions.\n   * @param {Function} toolFunction - The tool function to execute.\n   * @param {Object} args - The arguments to pass to the tool function.\n   * @returns {Promise<*>} The result of the tool function.\n   * @throws {Error} If the tool function throws an error.\n   */\n  async executeToolFunction(toolFunction, args) {\n\n    try {\n      if(typeof args !== 'object'){\n        args = JSON.parse(args);\n      }\n      const result = toolFunction(args);\n      if (result instanceof Promise) {\n        return await result;\n      } else {\n        return result;\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Makes an API call to the specified endpoint.\n   * @param {string} endpoint - The API endpoint to call.\n   * @param {Object} [options={}] - Options for the API call.\n   * @param {string} [options.method='POST'] - The HTTP method to use.\n   * @param {Object} [options.headers] - Additional headers to include in the request.\n   * @param {Object} [options.body] - The body of the request.\n   * @returns {Promise<Object>} The response data from the API call.\n   * @throws {Error} If the API call fails.\n   */\n  async makeApiCall(endpoint, options = {}, originalRequest) {\n    const url = `${this.baseUrl}/${endpoint}`;\n    const headers = {\n      'Authorization': `Bearer ${this.secretKey}`,\n      'Content-Type': 'application/json',\n      ...options.headers,\n    };\n\n    const response = await fetch(url, {\n      method: options.method || 'POST',\n      headers,\n      body: options.body ? JSON.stringify(options.body) : undefined,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    if (options.body && options.body.stream) {\n      return this.handleStreamedResponse({\n        readableStream: response.body,\n        originalRequest: originalRequest\n      });\n    } else {\n      const responseData = await response.text(); // Ensure we read the text response\n      return JSON.parse(responseData); // Parse the JSON manually\n    }\n  }\n\n  /**\n   * Creates a new FetchEventSource instance for handling streaming responses.\n   * @param {ReadableStream} stream - The stream to process.\n   * @returns {FetchEventSource} The created FetchEventSource instance.\n   */\n  async createFetchEventSource(args) {\n    const eventSource = new this.FetchEventSource(args, this);\n    return eventSource;\n  }\n\n  /**\n   * Processes data using the specified endpoint and agent IDs.\n   * @param {Object} params - The parameters for processing.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} params.data - The data to process.\n   * @param {string} [params.userId] - The user ID for stateful processing.\n   * @param {string} [params.sessionId] - The session ID for stateful processing.\n   * @param {boolean} [params.stateful] - Whether the processing is stateful.\n   * @param {boolean} [params.verbose] - Whether to enable verbose output.\n   * @param {Object} [params.tools] - The tools to use for processing (will map to functions)\n   * @param {Object} [params.functions] - The tool functions to use for processing.\n   * @param {boolean} [params.stream] - Whether to enable streaming responses.\n   * @returns {Promise<Object>} The result of the processing.\n   * @throws {Error} If required parameters are missing or if the processing fails.\n   */\n  async process({ endpointId, projectId, agentId, data, userId, sessionId, stateful, verbose, tools, functions, stream, on } = {}) {\n\n    let pIdTouse = projectId || endpointId || this.projectId;\n    \n    let url = `process/${pIdTouse}/${agentId || this.agentId}`;\n    if (verbose) url += \"?verbose=true\";\n\n    if (stateful && (!userId || !sessionId)) {\n      throw new Error(\"Stateful processing requires a userId and sessionId\");\n    }\n\n    if(tools && !functions){\n      if(tools.functions){\n        functions = tools.functions;\n      } else if(Array.isArray(tools)){\n        functions = tools;\n      }\n    }\n\n\n    const result = await this.makeApiCall(url, {\n      method: 'POST',\n      body: {\n        user_id: userId,\n        session_id: sessionId,\n        stateful,\n        data,\n        stream\n      }\n    }, {\n      stream,\n      data,\n      projectId: pIdTouse,\n      agentId,\n      userId,\n      sessionId,\n      stateful,\n      verbose,\n      functions,\n      on\n    });\n\n    if (stream) {\n      return;\n    } else {\n      if (functions && result.output_data && Array.isArray(result.output_data.content)) {\n        let messageAutoAdded = false;\n        let autoProcessedFunctions = 0;\n        let functionCalls = result.output_data.content.filter(content => content.type === 'function_call');\n        \n        for (let functionCall of functionCalls) {\n          if (functions && functions[functionCall.name]) {\n            \n            if (!messageAutoAdded) {\n              data.messages.push(result.output_data);\n              data.messages.push({\n                role: 'tool',\n                content: [],\n                timestamp: new Date().toISOString()\n              });\n              messageAutoAdded = true;\n            }\n\n            const tool_result = await this.executeToolFunction(functions[functionCall.name], functionCall.arguments);\n            data.messages[data.messages.length - 1].content.push({\n              type: 'function_response',\n              name: functionCall.name,\n              result: tool_result\n            });\n            autoProcessedFunctions++;\n          }\n        }\n\n        if(autoProcessedFunctions === functionCalls.length){\n\n          return await this.process({\n            projectId: pIdTouse,\n            agentId,\n            data,\n            userId,\n            sessionId,\n            stateful,\n            verbose,\n            tools,\n            stream,\n            on\n          });\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Initializes the event source by reading from the stream and emitting events.\n   */\n  handleStreamedResponse = ({readableStream, originalRequest}) => {\n    let buffer = '';\n    let eventType = null;\n    let eventData = [];\n    let decoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n    let cumulative_progress = \"\";\n\n    let emit = (eventType, dataPacket) => {\n      if(originalRequest.on && originalRequest.on[eventType]){\n        originalRequest.on[eventType](dataPacket);\n      }\n      if(originalRequest.on && originalRequest.on['all']){\n        originalRequest.on['all'](eventType, dataPacket);\n      }\n    }\n\n    const processEvent = async () => {\n      if (eventType && eventData.length) {\n        const dataString = eventData.join('\\n').trim();\n        try {\n          const dataPacket = JSON.parse(dataString);\n\n          if(eventType === 'outputProgress'){\n            if(dataPacket.partial_content === null || dataPacket.partial_content === undefined) dataPacket.partial_content = '';\n            cumulative_progress += dataPacket.partial_content;\n\n            dataPacket.content_so_far = cumulative_progress;\n          }\n\n          if(eventType === 'complete'){\n            \n            let autoProcessedFunctions = 0;\n            if(dataPacket.output_data && dataPacket.output_data.content && Array.isArray(dataPacket.output_data.content)){\n              let function_calls = dataPacket.output_data.content.filter(content => content.type === 'function_call');\n              \n              if (originalRequest.functions && function_calls.length > 0) {\n                \n                let messageAutoAdded = false;\n                for (let function_call of function_calls) {\n\n                  if (originalRequest.functions && originalRequest.functions[function_call.name]) {\n                    \n                    if (!messageAutoAdded) {\n                      originalRequest.data.messages.push(dataPacket.output_data);\n                      originalRequest.data.messages.push({\n                        role: 'tool',\n                        content: [],\n                        timestamp: new Date().toISOString()\n                      });\n                      messageAutoAdded = true;\n                    }\n\n                    emit('functionCall', function_call);\n\n                    const tool_result = await this.executeToolFunction(originalRequest.functions[function_call.name], function_call.arguments);\n                    \n                    originalRequest.data.messages[originalRequest.data.messages.length - 1].content.push({\n                      type: 'function_response',\n                      name: function_call.name,\n                      result: tool_result\n                    });\n\n                    autoProcessedFunctions++;\n                  }\n                }\n\n                if(autoProcessedFunctions === function_calls.length){\n\n                  return await this.process({\n                    projectId: originalRequest.projectId,\n                    agentId: originalRequest.agentId,\n                    data: originalRequest.data,\n                    userId: originalRequest.userId,\n                    sessionId: originalRequest.sessionId,\n                    stateful: originalRequest.stateful,\n                    verbose: originalRequest.verbose,\n                    tools: originalRequest.tools,\n                    stream: originalRequest.stream,\n                    on: originalRequest.on\n                  });\n                }\n              \n              }\n            }\n          }\n\n          emit(eventType, dataPacket);\n        } catch (error) {\n          emit('error', error);\n        }\n      }\n      eventType = null;\n      eventData = [];\n    };\n\n    const readStream = async () => {\n      const reader = readableStream.getReader();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            if (buffer.trim() !== '') {\n              buffer += '\\n\\n';\n              if (eventType) {\n                await processEvent();\n              } else {\n                try {\n                  const dataPacket = JSON.parse(buffer.trim());\n                  emit('errorEvent', dataPacket);\n                } catch (error) {\n                  emit('error', { message: 'Failed to parse JSON', buffer });\n                }\n              }\n            }\n            emit('close');\n            break;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop(); // Retain incomplete line\n\n          lines.forEach(async (line) =>{\n            if (line.startsWith('event: ')) {\n              if (eventType !== null) {\n                await processEvent();\n              }\n              eventType = line.substring(7).trim();\n            } else if (line.startsWith('data: ')) {\n              eventData.push(line.substring(6));\n            } else if (line.trim() === '') {\n              await processEvent();\n            }\n          });\n        }\n      } catch (error) {\n        emit('error', { message: 'Stream read error', error });\n      }\n    };\n\n    readStream();\n  }\n\n  /**\n   * Retrieves the history for a specific session.\n   * @param {Object} params - The parameters for retrieving the history.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {string} params.userId - The user ID.\n   * @param {string} params.sessionId - The session ID.\n   * @param {string} [params.startAfter] - The starting point for history retrieval.\n   * @returns {Promise<Object>} The history data.\n   * @throws {Error} If the API call fails.\n   */\n  async getHistory({ endpointId, projectId, agentId, userId, sessionId, startAfter } = {}) {\n    const endpoint = `history/${projectId || endpointId || this.projectId}/${agentId || this.agentId}/${userId}/${sessionId}`;\n    const params = startAfter ? { startAfter } : {};\n\n    return this.makeApiCall(endpoint, {\n      method: 'GET',\n      params: params,\n    });\n  }\n\n  /**\n   * Submits a report for a specific session.\n   * @param {Object} params - The parameters for submitting the report.\n   * @param {string} [params.endpointId] - The endpoint ID (deprecated).\n   * @param {string} [params.projectId] - The project ID (replacement for endpoint ID).\n   * @param {string} [params.agentId] - The agent ID.\n   * @param {Object} [params.data] - The optional JSON object containing the detailed API response.\n   * @param {string} [params.userId] - The user ID.\n   * @param {string} [params.sessionId] - The session ID.\n   * @param {string} params.type - The type of the report (e.g., 'positive', 'negative', 'neutral').\n   * @param {string} params.category - The category of the report (e.g., 'accuracy', 'hallucination').\n   * @param {string} [params.details] - Additional details provided by the user (max 500 characters).\n   * @returns {Promise<Object>} The result of the report submission.\n   * @throws {Error} If the API call fails.\n   */\n  async report({ endpointId, projectId, agentId, data, userId, sessionId, type, category, details } = {}) {\n    // Construct the endpoint URL using provided or default IDs\n    const url = `report/${projectId || endpointId || this.projectId}/${agentId || this.agentId}`;\n\n    // Prepare the body of the POST request\n    const requestBody = {\n      user_id: userId || null,        // Optional: User ID\n      session_id: sessionId || null,  // Optional: Session ID\n      data: data || null,             // Optional: Detailed API response data (JSON object)\n      type,                           // Required: Type of the report (string)\n      category: category || null,     // Required: Category of the report (string)\n      details: details || null        // Optional: Additional user-provided details (string)\n    };\n\n    // Make the API call to submit the report\n    try {\n      const result = await this.makeApiCall(url, {\n        method: 'POST',\n        body: requestBody,\n      });\n      \n      return result;\n    } catch (error) {\n      console.error('Error submitting report:', error);\n      throw new Error('Failed to submit report');\n    }\n  }\n\n\n\n  /**\n   * Formats an error object for better readability.\n   * @param {Error} error - The error object to format.\n   * @returns {Object} An object containing the formatted error message and status code.\n   */\n  formatError(error) {\n    let errorMessage = \"An error occurred\";\n    let statusCode = null;\n\n    if (error.response) {\n      errorMessage = `API Error: ${error.response.statusText || error.message}`;\n      statusCode = error.response.status;\n    } else if (error.request) {\n      errorMessage = \"Network Error: No response received from the server.\";\n    } else {\n      errorMessage = `Request Error: ${error.message}`;\n    }\n\n    return { errorMessage, statusCode };\n  }\n}\n\nexport default ZeroWidthApi;","// ZeroWidthApiMiddleware.js\nimport express from 'express';\nimport ZeroWidthApi from './ZeroWidthApi.js'; \nimport compression from 'compression';\n\nconst processRouteHandler = async ({ req, res, next, secretKey, baseUrl, returnsResponse, variables, functions, on, useCompression }) => {\n  const { project_id, agent_id } = req.params;\n\n  const zerowidthApi = new ZeroWidthApi({\n    secretKey: secretKey,\n    projectId: project_id,\n    agentId: agent_id,\n    baseUrl: baseUrl\n  });\n\n\n  const processApiResponse = async (requestData) => {\n\n    let eventsSentCounter = 0;\n    let closeTimeout;\n\n    if(variables){\n      if(typeof variables === 'function'){\n        let serverVariables = await variables(req);\n        requestData.data.variables = {\n          ...requestData.data.variables,\n          ...serverVariables\n        }\n      } else if(typeof variables === 'object'){\n        requestData.data.variables = {\n          ...requestData.data.variables,\n          ...variables\n        }\n      }\n    }\n\n    try {\n      const result = await zerowidthApi.process({\n        ...requestData,\n        functions: functions,\n        on: {\n          ...on,\n          all: (eventType, data) => {\n\n            // Was the original requestData in stream mode?\n            if (requestData.stream) {\n              clearTimeout(closeTimeout);\n\n              if(eventsSentCounter === 0) {\n                // open the SSE\n                res.writeHead(200, {\n                  'Content-Type': 'text/event-stream',\n                  'Cache-Control': 'no-cache',\n                  'Connection': 'keep-alive',\n                  'X-Accel-Buffering': 'no'\n                });\n              }\n\n              eventsSentCounter++;\n\n              // if the event is complete, close the connection after 1 second\n              if(eventType === 'close') {\n                closeTimeout = setTimeout(() => {\n                  res.end();\n                }, 5000);\n                return;\n              }\n\n              // if the event is open, clear the timeout in case this is a reconnection\n              if(eventType === 'open') {\n                clearTimeout(closeTimeout);\n                if(eventsSentCounter > 1) {\n                  return;\n                } \n              }\n\n              \n              res.write(`event: ${eventType}\\n`);\n              res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\n              if(useCompression) res.flush();\n            }\n          }\n        }\n      });\n\n      if(on && on.complete && result) {\n        on.complete(result);\n      }\n\n      return result;\n    } catch (error) {\n      console.error('API call failed:', error);\n\n      if(on && on.error && error.response) {\n        on.error(error.response.data);\n      }\n\n      throw error;\n    }\n  };\n\n  try {\n    const finalResult = await processApiResponse(req.body);\n\n    if(req.body.stream){\n      // do nothing, on handlers will handle the response\n    } else {\n      if (returnsResponse) {\n        res.json(finalResult.output_data);\n      } else {\n        req.zerowidthResult = finalResult;\n        next();\n      }\n    }\n  } catch (error) {\n    next(error);\n  }\n};\n\n\nconst historyRouteHandler = async ({req, res, next, secretKey, baseUrl, on, returnsResponse}) => {\n  const { project_id, agent_id, user_id, session_id } = req.params;\n  const { startAfter } = req.query;\n  \n  \n  const zerowidthApi = new ZeroWidthApi({\n    secretKey: secretKey,\n    projectId: project_id,\n    agentId: agent_id,\n    baseUrl: baseUrl\n  });\n\n  try {\n    const history = await zerowidthApi.getHistory({\n      userId: user_id,\n      sessionId: session_id,\n      startAfter: startAfter,\n    });\n\n    if (onProcess) {\n      onProcess(history);\n    } \n    \n    if (returnsResponse) {\n      res.json(history);\n    } else {\n      req.zerowidthHistory = history;\n      next();\n    }\n  } catch (error) {\n    console.error('History retrieval failed:', error);\n\n    if(onError && error.response) {\n      onError(error.response.data);\n    }\n\n    res.status(500).send('Internal Server Error');\n  }\n};\n\nexport default function ZeroWidthApiExpress({ secretKey, baseUrl, on, variables, returnsResponse = true, functions, useCompression = true}) {\n  const router = express.Router();\n\n  if(useCompression){\n    router.use(compression());\n  }\n\n  // POST route to process data\n  router.post('/process/:project_id/:agent_id', (req, res, next) => {\n    processRouteHandler({req, res, next, secretKey, baseUrl, on, variables, returnsResponse, functions, useCompression});\n  });\n\n  // GET route to retrieve history\n  router.get('/history/:project_id/:agent_id/:user_id/:session_id', (req, res, next) => {\n    historyRouteHandler({req, res, next, secretKey, baseUrl, on, returnsResponse});\n  });\n\n  return router;\n}\n"],"names":[],"version":3,"file":"main.js.map"}